diff --git a/Application/build.gradle b/Application/build.gradle
index 9825b3e..52a733a 100644
--- a/Application/build.gradle
+++ b/Application/build.gradle
@@ -6,7 +6,7 @@ buildscript {
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:7.1.3'
+        classpath 'com.android.tools.build:gradle:4.2.2'
     }
 }
 
diff --git a/Application/src/main/AndroidManifest.xml b/Application/src/main/AndroidManifest.xml
index 8b642e5..41df1ec 100644
--- a/Application/src/main/AndroidManifest.xml
+++ b/Application/src/main/AndroidManifest.xml
@@ -18,7 +18,6 @@
 
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:tools="http://schemas.android.com/tools"
     package="com.example.android.bluetoothlegatt"
     android:versionCode="1"
     android:versionName="1.0">
@@ -40,8 +39,6 @@
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
     <!--外部存储的读权限-->
     <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
-    <uses-permission android:name="android.permission.WRITE_SECURE_SETTINGS"
-        tools:ignore="ProtectedPermissions" />
     <application android:label="@string/app_name"
         android:icon="@drawable/ic_launcher"
         android:theme="@android:style/Theme.Holo.Light">
diff --git a/Application/src/main/java/com/example/android/bluetoothlegatt/BluetoothLeService.java b/Application/src/main/java/com/example/android/bluetoothlegatt/BluetoothLeService.java
index 5b36605..e2bcc6e 100644
--- a/Application/src/main/java/com/example/android/bluetoothlegatt/BluetoothLeService.java
+++ b/Application/src/main/java/com/example/android/bluetoothlegatt/BluetoothLeService.java
@@ -99,54 +99,52 @@ public class BluetoothLeService extends Service {
 
     // Implements callback methods for GATT events that the app cares about.  For example,
     // connection change and services discovered.
-    private BluetoothGattCallback getGattCallback() {
-        return new BluetoothGattCallback() { // TODO: duplicate it for testing connect 2 devices?
-            @Override
-            public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {
-                String intentAction;
-                if (newState == BluetoothProfile.STATE_CONNECTED) {
-                    intentAction = ACTION_GATT_CONNECTED;
-                    mConnectionState = STATE_CONNECTED;
-                    broadcastUpdate(gatt.getDevice().getAddress(), intentAction);
-                    Log.i(TAG, "Connected to GATT server.");
-                    // Attempts to discover services after successful connection.
-                    Log.i(TAG, "Attempting to start service discovery:" +
-                            mBluetoothGatt.discoverServices());
-
-                } else if (newState == BluetoothProfile.STATE_DISCONNECTED) {
-                    intentAction = ACTION_GATT_DISCONNECTED;
-                    mConnectionState = STATE_DISCONNECTED;
-                    Log.i(TAG, "Disconnected from GATT server.");
-                    broadcastUpdate(gatt.getDevice().getAddress(), intentAction);
-                }
+    private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback() {
+        @Override
+        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {
+            String intentAction;
+            if (newState == BluetoothProfile.STATE_CONNECTED) {
+                intentAction = ACTION_GATT_CONNECTED;
+                mConnectionState = STATE_CONNECTED;
+                broadcastUpdate(gatt.getDevice().getAddress(), intentAction);
+                Log.i(TAG, "Connected to GATT server.");
+                // Attempts to discover services after successful connection.
+                Log.i(TAG, "Attempting to start service discovery:" +
+                        mBluetoothGatt.discoverServices());
+
+            } else if (newState == BluetoothProfile.STATE_DISCONNECTED) {
+                intentAction = ACTION_GATT_DISCONNECTED;
+                mConnectionState = STATE_DISCONNECTED;
+                Log.i(TAG, "Disconnected from GATT server.");
+                broadcastUpdate(gatt.getDevice().getAddress(), intentAction);
             }
+        }
 
-            @Override
-            public void onServicesDiscovered(BluetoothGatt gatt, int status) {
-                if (status == BluetoothGatt.GATT_SUCCESS) {
-                    broadcastUpdate(gatt.getDevice().getAddress(), ACTION_GATT_SERVICES_DISCOVERED);
-                } else {
-                    Log.w(TAG, "onServicesDiscovered received: " + status);
-                }
+        @Override
+        public void onServicesDiscovered(BluetoothGatt gatt, int status) {
+            if (status == BluetoothGatt.GATT_SUCCESS) {
+                broadcastUpdate(gatt.getDevice().getAddress(), ACTION_GATT_SERVICES_DISCOVERED);
+            } else {
+                Log.w(TAG, "onServicesDiscovered received: " + status);
             }
+        }
 
-            @Override
-            public void onCharacteristicRead(BluetoothGatt gatt,
-                                             BluetoothGattCharacteristic characteristic,
-                                             int status) {
-
-                if (status == BluetoothGatt.GATT_SUCCESS) {
-                    broadcastUpdate(gatt.getDevice().getAddress(), ACTION_DATA_AVAILABLE, characteristic);
-                }
-            }
+        @Override
+        public void onCharacteristicRead(BluetoothGatt gatt,
+                                         BluetoothGattCharacteristic characteristic,
+                                         int status) {
 
-            @Override
-            public void onCharacteristicChanged(BluetoothGatt gatt,
-                                                BluetoothGattCharacteristic characteristic) {
+            if (status == BluetoothGatt.GATT_SUCCESS) {
                 broadcastUpdate(gatt.getDevice().getAddress(), ACTION_DATA_AVAILABLE, characteristic);
             }
-        };
-    }
+        }
+
+        @Override
+        public void onCharacteristicChanged(BluetoothGatt gatt,
+                                            BluetoothGattCharacteristic characteristic) {
+            broadcastUpdate(gatt.getDevice().getAddress(), ACTION_DATA_AVAILABLE, characteristic);
+        }
+    };
 
     private void broadcastUpdate(final String address, final String action) {
         final Intent intent = new Intent(action);
@@ -267,25 +265,41 @@ public class BluetoothLeService extends Service {
      */
     @RequiresApi(api = Build.VERSION_CODES.M)
     public boolean connect(final String address) {
+
+//        // TODO: save data to file
+//        try {
+//            mDataFileOutStream = openFileOutput("BLE_Received_Data.txt", Context.MODE_APPEND);
+//        } catch (FileNotFoundException e) {
+//            Log.e(TAG, Log.getStackTraceString(e));
+//        }
+//        Log.d(TAG, "Saved file created.");
+//        Toast.makeText(this, R.string.file_opened + " " + getFilesDir().toString() + "BLE_Received_Data.txt",Toast.LENGTH_SHORT).show();
+
         if (mBluetoothAdapter == null || address == null){
             Log.w(TAG, "BluetoothAdapter not initialized or unspecified address.");
             return false;
         }
 
+        // Previously connected device.  Try to reconnect.
+//        if (mBluetoothDeviceAddress != null && address.equals(mBluetoothDeviceAddress)
+//                && mBluetoothGatt != null) {
+//            Log.d(TAG, "Trying to use an existing mBluetoothGatt for connection.");
+//            if (mBluetoothGatt.connect()) {
+//                mConnectionState = STATE_CONNECTING;
+//                return true;
+//            } else {
+//                return false;
+//            }
+//        }
        if (mBluetoothDeviceDict.containsKey(address) && mBluetoothDeviceDict.get(address) != null) {
             Log.d(TAG, "Trying to use an existing mBluetoothGatt for connection.");
             if (mBluetoothDeviceDict.get(address).connect()) {
                 mConnectionState = STATE_CONNECTING;
                 return true;
-            }
-            // ???WHATS THE CODE BEHIND
-             else {
+            } else {
                 return false;
-//                disconnect(address);
-//                connect(address); //recursive
             }
-       }
-
+        }
 
         final BluetoothDevice device = mBluetoothAdapter.getRemoteDevice(address);
         if (device == null) {
@@ -294,19 +308,17 @@ public class BluetoothLeService extends Service {
         }
         // We want to directly connect to the device, so we are setting the autoConnect
         // parameter to false.
-        mBluetoothGatt = device.connectGatt(this, true, getGattCallback(), BluetoothDevice.TRANSPORT_LE);// TODO: should autoConnect be changed?
+        mBluetoothGatt = device.connectGatt(this, false, mGattCallback, BluetoothDevice.TRANSPORT_LE);//TODO:CHANGED!
         Log.d(TAG, "Trying to create a new connection.");
         mBluetoothDeviceAddress = address;
 
         //add device-gatt to the dict
         if(address != null && mBluetoothGatt != null){
             mBluetoothDeviceDict.put(address, mBluetoothGatt);
-        } else {
-            return false;
         }
 
         mConnectionState = STATE_CONNECTING;
-        return mBluetoothGatt.connect();
+        return true;
     }
 
     /**
@@ -320,6 +332,13 @@ public class BluetoothLeService extends Service {
             Log.w(TAG, "BluetoothAdapter not initialized");
             return;
         }
+//        // TODO: close data file
+//        try {
+//            mDataFileOutStream.close();
+//        } catch (IOException e) {
+//            Log.e(TAG, Log.getStackTraceString(e));
+//        }
+//        Toast.makeText(this, R.string.file_closed,Toast.LENGTH_SHORT).show();
 
         mBluetoothGatt.disconnect();
         if (mBluetoothDeviceDict.containsKey(mBluetoothDeviceAddress)) mBluetoothDeviceDict.remove(mBluetoothDeviceAddress);
@@ -332,7 +351,6 @@ public class BluetoothLeService extends Service {
         }
         mBluetoothDeviceDict.get(address).disconnect();
         mBluetoothDeviceDict.remove(address);
-        //gc();
     }
 
     /**
@@ -351,10 +369,15 @@ public class BluetoothLeService extends Service {
             mBluetoothDeviceDict.forEach((s, bluetoothGatt) -> {
                 bluetoothGatt.close();
             });
-            mBluetoothDeviceDict.clear();
         }
+//        // TODO: close data file
+//        try {
+//            mDataFileOutStream.close();
+//        } catch (IOException e) {
+//            Log.e(TAG, Log.getStackTraceString(e));
+//        }
+//        Toast.makeText(this, R.string.file_closed,Toast.LENGTH_SHORT).show();
 
-        mBluetoothDeviceAddress = null;
         mBluetoothGatt = null;
     }
 
@@ -444,11 +467,5 @@ public class BluetoothLeService extends Service {
 
         return mBluetoothGatt.getServices();
     }
-
-    public List<BluetoothGattService> getSupportedGattServices(String address) {
-        if (!mBluetoothDeviceDict.containsKey(address)) return null;
-
-        return mBluetoothDeviceDict.get(address).getServices();
-    }
 }
 
diff --git a/Application/src/main/java/com/example/android/bluetoothlegatt/MultiDeviceControlActivity.java b/Application/src/main/java/com/example/android/bluetoothlegatt/MultiDeviceControlActivity.java
index 314f778..a509be9 100644
--- a/Application/src/main/java/com/example/android/bluetoothlegatt/MultiDeviceControlActivity.java
+++ b/Application/src/main/java/com/example/android/bluetoothlegatt/MultiDeviceControlActivity.java
@@ -3,7 +3,6 @@ package com.example.android.bluetoothlegatt;
 import android.annotation.SuppressLint;
 import android.app.Activity;
 import android.app.ListActivity;
-import android.bluetooth.BluetoothDevice;
 import android.bluetooth.BluetoothGattCharacteristic;
 import android.bluetooth.BluetoothGattService;
 import android.content.BroadcastReceiver;
@@ -12,7 +11,6 @@ import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.ServiceConnection;
-import android.content.pm.PackageManager;
 import android.graphics.Bitmap;
 import android.graphics.Rect;
 import android.net.Uri;
@@ -21,7 +19,6 @@ import android.os.Bundle;
 import android.os.IBinder;
 import android.os.ParcelFileDescriptor;
 import android.support.annotation.RequiresApi;
-import android.support.v4.app.ActivityCompat;
 import android.util.DisplayMetrics;
 import android.util.Log;
 import android.view.LayoutInflater;
@@ -34,6 +31,7 @@ import android.widget.BaseAdapter;
 import android.widget.ExpandableListView;
 import android.widget.ListAdapter;
 import android.widget.ListView;
+import android.widget.SimpleExpandableListAdapter;
 import android.widget.TextView;
 import android.widget.Toast;
 
@@ -42,7 +40,7 @@ import java.io.FileOutputStream;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.HashMap;
-import java.util.Objects;
+import java.util.List;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 
 public class MultiDeviceControlActivity extends ListActivity {
@@ -51,13 +49,8 @@ public class MultiDeviceControlActivity extends ListActivity {
     public static final String EXTRAS_DEVICE_LIST = "DEVICE_LIST";
     private final String LIST_NAME = "NAME";
     private final String LIST_UUID = "UUID";
-    //先定义
-    private static final int REQUEST_EXTERNAL_STORAGE = 1;
 
-    private static String[] PERMISSIONS_STORAGE = {
-            "android.permission.READ_EXTERNAL_STORAGE",
-            "android.permission.WRITE_EXTERNAL_STORAGE" };
-    //private static final int CREATE_FILE = 1;
+    private static final int CREATE_FILE = 1;
 
     private MultiControlGattListAdapter mMultiDeviceListAdapter;
     private BluetoothLeService mBluetoothLeService;
@@ -65,47 +58,29 @@ public class MultiDeviceControlActivity extends ListActivity {
     private ArrayList<BluetoothLeData> mDeviceList;
     private HashMap<String, Boolean> mDeviceConnectionState = new HashMap<>();
     private HashMap<String, String> mDeviceDataValue = new HashMap<>();
-    //private HashMap<String, ExpandableListView> mDeviceGattServicesListView = new HashMap<>();
-    //private HashMap<String, ArrayList<ArrayList<BluetoothGattCharacteristic>>> mDeviceGattCharacteristics =
-    //        new HashMap<>();
+    private HashMap<String, ExpandableListView> mDeviceGattServicesListView = new HashMap<>();
+    private HashMap<String, ArrayList<ArrayList<BluetoothGattCharacteristic>>> mDeviceGattCharacteristics =
+            new HashMap<>();
     private HashMap<String, BluetoothGattCharacteristic> mDeviceNotifyCharacteristic = new HashMap<>();
-    private HashMap<String, FileOutputStream> mDeviceOutputFileDict = new HashMap<>();
-    //private ReentrantReadWriteLock mReadWriteLock = new ReentrantReadWriteLock();
 
-//   private Uri mInitialUri;
-//   private int mTakeFlags;
+    private ReentrantReadWriteLock mReadWriteLock = new ReentrantReadWriteLock();
 
-    //private HashMap<String, String> mBleAddrGattDict = new HashMap<>();
-    //private HashMap<String, ParcelFileDescriptor> mBleFileDesDict = new HashMap<>();
-    //private HashMap<String, FileOutputStream> mBleFileOutStreamDict = new HashMap<>();
+    private Uri mInitialUri;
+    private int mTakeFlags;
+
+    private HashMap<String, String> mBleAddrGattDict = new HashMap<>();
+    private HashMap<String, ParcelFileDescriptor> mBleFileDesDict = new HashMap<>();
+    private HashMap<String, FileOutputStream> mBleFileOutStreamDict = new HashMap<>();
 
 
-//    // for open and saving data
-//    private void initialUri() {
-//        Intent intent = new Intent(Intent.ACTION_CREATE_DOCUMENT);
-//        intent.addCategory(Intent.CATEGORY_OPENABLE);
-//        intent.setType("text/plain");
-//        intent.putExtra(Intent.EXTRA_TITLE, R.string.uri_initial);
-//
-//        startActivityForResult(intent, CREATE_FILE);
-//    }
-    //private static final int CREATE_FILE = 1;
     // for open and saving data
-    private void createFile(String address) {
-        if(!mDeviceOutputFileDict.containsKey(address) || mDeviceOutputFileDict.get(address) == null) {
-            Intent intent = new Intent(Intent.ACTION_CREATE_DOCUMENT);
-            intent.addCategory(Intent.CATEGORY_OPENABLE);
-            intent.setType("text/plain");
-            intent.putExtra(Intent.EXTRA_TITLE, address.replace(':', '_') + ".txt");
-
-//        // Optionally, specify a URI for the directory that should be opened in
-//        // the system file picker when your app creates the document.
-//        intent.putExtra(DocumentsContract.EXTRA_INITIAL_URI, pickerInitialUri);
-
-            startActivityForResult(intent, mMultiDeviceListAdapter.getItemId(address)); // request code as item id
-        } else {
-            //pass
-        }
+    private void initialUri() {
+        Intent intent = new Intent(Intent.ACTION_CREATE_DOCUMENT);
+        intent.addCategory(Intent.CATEGORY_OPENABLE);
+        intent.setType("text/plain");
+        intent.putExtra(Intent.EXTRA_TITLE, R.string.uri_initial);
+
+        startActivityForResult(intent, CREATE_FILE);
     }
 
     @SuppressLint("WrongConstant")
@@ -113,95 +88,63 @@ public class MultiDeviceControlActivity extends ListActivity {
     @Override
     public void onActivityResult(int requestCode, int resultCode,
                                  Intent resultData) {
-        if (requestCode <= mMultiDeviceListAdapter.getCount()
+        if (requestCode == CREATE_FILE
                 && resultCode == Activity.RESULT_OK) {
             // The result data contains a URI for the document or directory that
             // the user selected.
-
             if (resultData != null) {
-                Uri initialUri = resultData.getData();
-                final int takeFlags = resultData.getFlags()
+                mInitialUri = resultData.getData();
+                mTakeFlags = resultData.getFlags()
                         & (Intent.FLAG_GRANT_READ_URI_PERMISSION
                         | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
-                // Check for the freshest data.
-                getContentResolver().takePersistableUriPermission(initialUri, takeFlags);
-                // Perform operations on the document using its URI.
-                try {
-                    FileOutputStream fo = new FileOutputStream(getContentResolver().openFileDescriptor(initialUri, "w").getFileDescriptor());
-                    mDeviceOutputFileDict.put(mMultiDeviceListAdapter.getDevice(requestCode).getDeviceAddress(), fo);
-                    Toast.makeText(this, R.string.file_created, Toast.LENGTH_SHORT).show();
-                } catch (FileNotFoundException e) {
-                    e.printStackTrace();
-                }
 
-                Toast.makeText(this, R.string.file_opened, Toast.LENGTH_SHORT).show();
+                // Perform operations on the document using its URI.
+                Toast.makeText(this, R.string.uri_initialized, Toast.LENGTH_SHORT).show();
             }
         }
     }
 
-    /*当设备点击/连接时 确定保存文件 自动激活TX特征*/
-    //onListDeviceClickedOrConnectedOr...
-    private void openOutputStream(String address){
-//        if(!mDeviceOutputFileDict.containsKey(address)) {
-//            FileOutputStream fos;
-//            try {
-//                fos = openFileOutput(address.trim().replace(':', '.').concat(".txt"), MODE_APPEND);//处理文件名
-//                mDeviceOutputFileDict.put(address, fos);
-//                Toast.makeText(this, R.string.file_created, Toast.LENGTH_SHORT).show();
-//            } catch (Exception e) {
-//                e.printStackTrace();
+    @RequiresApi(api = Build.VERSION_CODES.KITKAT)
+    private FileOutputStream getOutputStream(String address) {
+//        try {
+//            if (mBleFileOutStreamDict.containsKey(address))
+//                return mBleFileOutStreamDict.get(address);
+//            else {
+//                Uri fileOutputUri = new Uri.Builder().path(mInitialUri.getPath()).appendPath(address.replace(':', '-') + ".txt").build();
+//                // Check for the freshest data.
+//                getContentResolver().takePersistableUriPermission(fileOutputUri, mTakeFlags);
+//
+//                ParcelFileDescriptor parcelFileDescriptor = getContentResolver().
+//                        openFileDescriptor(fileOutputUri, "w");
+//                FileOutputStream fileOutputStream =
+//                        new FileOutputStream(parcelFileDescriptor.getFileDescriptor());
+//                mBleFileDesDict.put(address, parcelFileDescriptor);
+//                mBleFileOutStreamDict.put(address, fileOutputStream);
+//                return fileOutputStream;
 //            }
-//        } else {
-//            Toast.makeText(this, R.string.file_existed, Toast.LENGTH_SHORT).show();
+//        } catch (FileNotFoundException e) {
+//            e.printStackTrace();
 //        }
-        createFile(address);
-        runOnUiThread(()-> {
-            //激活TX特征Notify
-            // DONE: - determine NOTIFY or READ!! : NOTIFY
-            if (!mDeviceNotifyCharacteristic.containsKey(address)) {
-               for (BluetoothGattService service : mBluetoothLeService.getSupportedGattServices(address)) {
-                   for (BluetoothGattCharacteristic characteristic : service.getCharacteristics()) {
-                       if (characteristic.getUuid().toString().equalsIgnoreCase(SampleGattAttributes.BLE_UART_TX)) {//TO IGNORE CASE
-                           mDeviceNotifyCharacteristic.put(address, characteristic);
-                            mBluetoothLeService.setCharacteristicNotification(
-                                    address,
-                                    characteristic,
-                                   true);
-                           Log.d(TAG, "GATT PROPERTY_NOTIFY: " + address);
-                       }
-                   }
-               }
-            } else {
-                mBluetoothLeService.setCharacteristicNotification(
-                        address,
-                        mDeviceNotifyCharacteristic.get(address),
-                        true);
-            Log.d(TAG, "GATT PROPERTY_NOTIFY: " + address);
-        }
-        });
+        return null;
     }
 
-    //must called when OutPutStream should be closed on disconnected...
     private void closeOutputStream(String address) {
-        if(mDeviceOutputFileDict.containsKey(address)) {
-            try {
-                mDeviceOutputFileDict.get(address).close();
-            } catch (IOException e){
-                Log.e(TAG, "closeOutputStream: " + address);
-                e.printStackTrace();
-            }
-            finally {
-                mDeviceOutputFileDict.remove(address);
-                Toast.makeText(this, R.string.file_closed, Toast.LENGTH_SHORT).show();
-            }
-        }
-        if(mDeviceNotifyCharacteristic.containsKey(address)){
-            mDeviceNotifyCharacteristic.remove(address);
-            Log.d(TAG, "REMOVED: GATT PROPERTY_NOTIFY: " + address);
-        }
+//        // Let the document provider know you're done by closing the stream.
+//        try {
+//            if (!mBleFileOutStreamDict.containsKey(address) && !mBleFileDesDict.containsKey(address))
+//                ;
+//            else {
+//                mBleFileOutStreamDict.get(address).close();
+//                mBleFileOutStreamDict.remove(address);
+//                mBleFileDesDict.get(address).close();
+//                mBleFileDesDict.remove(address);
+//            }
+//            Toast.makeText(this, R.string.file_closed, Toast.LENGTH_SHORT).show();
+//        } catch (IOException e) {
+//            e.printStackTrace();
+//        }
     }
 
-
     // Code to manage Service lifecycle.
     private final ServiceConnection mServiceConnection = new ServiceConnection() {
 
@@ -241,39 +184,32 @@ public class MultiDeviceControlActivity extends ListActivity {
             final String address = intent.getStringExtra(BluetoothLeService.EXTRA_ADDRESS);
             if (BluetoothLeService.ACTION_GATT_CONNECTED.equals(action)) {
                 //mConnected = true;
-                mDeviceConnectionState.put(address, true);//updateConnectionState(address, true);
+                updateConnectionState(address, true);
                 invalidateOptionsMenu();
             } else if (BluetoothLeService.ACTION_GATT_DISCONNECTED.equals(action)) {
                 //mConnected = false;
-                mDeviceConnectionState.put(address, false);//updateConnectionState(address, false);
-                mDeviceDataValue.remove(address);
+                updateConnectionState(address, false);
                 invalidateOptionsMenu();
                 clearUI(address);
                 //TODO: ...
                 closeOutputStream(address);
             } else if (BluetoothLeService.ACTION_GATT_SERVICES_DISCOVERED.equals(action)) {
                 // Show all the supported services and characteristics on the user interface.
-                //displayGattServices(address, mBluetoothLeService.getSupportedGattServices(address));
-
-                //set Notify Characteristic & open a FileOutputStream
-                openOutputStream(address);
+                displayGattServices(address, mBluetoothLeService.getSupportedGattServices());
             } else if (BluetoothLeService.ACTION_DATA_AVAILABLE.equals(action)) {
                 String data = intent.getStringExtra(BluetoothLeService.EXTRA_DATA);
-                mDeviceDataValue.put(address, data);//displayData(address, data); // decouple data receive and data display (buffer)
+                displayData(address, data);
                 // write to file
+                //TODO:...
                 try {
-                    //mReadWriteLock.readLock().lock();
-                    Objects.requireNonNull(mDeviceOutputFileDict.get(address)).write(data.getBytes());//getOutputStream
-                    Objects.requireNonNull(mDeviceOutputFileDict.get(address)).flush();
-                    //mReadWriteLock.readLock().unlock();
+                    FileOutputStream fos = getOutputStream(address);
+                    mBleFileOutStreamDict.put(address, fos);
+                    fos.write(data.getBytes());
+                    fos.flush();
                 } catch (IOException e) {
-                    Toast.makeText(context, R.string.file_error, Toast.LENGTH_SHORT).show();
-                    Log.e(TAG, "onReceive: ble data or fos error");
-
                     e.printStackTrace();
                 }
-                invalidateOptionsMenu();
-                //else { }
+                //else { Toast.makeText(this, R.string.file_error, Toast.LENGTH_SHORT).show(); }
                 // TODO：处理危险范围...再显示
                 //notifyData(intent.getStringExtra(BluetoothLeService.EXTRA_DATA));
             }
@@ -281,15 +217,76 @@ public class MultiDeviceControlActivity extends ListActivity {
         }
     };
 
+    // Demonstrates how to iterate through the supported GATT Services/Characteristics.
+    // In this sample, we populate the data structure that is bound to the ExpandableListView
+    // on the UI.
+    private void displayGattServices(String address, List<BluetoothGattService> gattServices) {
+        if (gattServices == null) return;
+        String uuid = null;
+        String unknownServiceString = getResources().getString(R.string.unknown_service);
+        String unknownCharaString = getResources().getString(R.string.unknown_characteristic);
+        ArrayList<HashMap<String, String>> gattServiceData = new ArrayList<HashMap<String, String>>();
+        ArrayList<ArrayList<HashMap<String, String>>> gattCharacteristicData
+                = new ArrayList<ArrayList<HashMap<String, String>>>();
+        ArrayList<ArrayList<BluetoothGattCharacteristic>> mGattCharacteristics = new ArrayList<ArrayList<BluetoothGattCharacteristic>>();
+        mReadWriteLock.readLock().lock();
+        ExpandableListView mGattServicesList = mDeviceGattServicesListView.get(address);
+        mReadWriteLock.readLock().unlock();
+
+        // Loops through available GATT Services.
+        for (BluetoothGattService gattService : gattServices) {
+            HashMap<String, String> currentServiceData = new HashMap<String, String>();
+            uuid = gattService.getUuid().toString();
+            currentServiceData.put(
+                    LIST_NAME, SampleGattAttributes.lookup(uuid.toUpperCase(), unknownServiceString));
+            currentServiceData.put(LIST_UUID, uuid);
+            gattServiceData.add(currentServiceData);
+
+            ArrayList<HashMap<String, String>> gattCharacteristicGroupData =
+                    new ArrayList<HashMap<String, String>>();
+            List<BluetoothGattCharacteristic> gattCharacteristics =
+                    gattService.getCharacteristics();
+            ArrayList<BluetoothGattCharacteristic> charas =
+                    new ArrayList<BluetoothGattCharacteristic>();
+
+            // Loops through available Characteristics.
+            for (BluetoothGattCharacteristic gattCharacteristic : gattCharacteristics) {
+                charas.add(gattCharacteristic);
+                HashMap<String, String> currentCharaData = new HashMap<String, String>();
+                uuid = gattCharacteristic.getUuid().toString();
+                currentCharaData.put(
+                        LIST_NAME, SampleGattAttributes.lookup(uuid.toUpperCase(), unknownCharaString));
+                currentCharaData.put(LIST_UUID, uuid);
+                gattCharacteristicGroupData.add(currentCharaData);
+            }
+            mGattCharacteristics.add(charas);
+            gattCharacteristicData.add(gattCharacteristicGroupData);
+        }
 
+        SimpleExpandableListAdapter gattServiceAdapter = new SimpleExpandableListAdapter(
+                this,
+                gattServiceData,
+                android.R.layout.simple_expandable_list_item_2,
+                new String[]{LIST_NAME, LIST_UUID},
+                new int[]{android.R.id.text1, android.R.id.text2},
+                gattCharacteristicData,
+                android.R.layout.simple_expandable_list_item_2,
+                new String[]{LIST_NAME, LIST_UUID},
+                new int[]{android.R.id.text1, android.R.id.text2}
+        );
+        mGattServicesList.setAdapter(gattServiceAdapter);
+        mReadWriteLock.writeLock().lock();
+        mDeviceGattCharacteristics.put(address, mGattCharacteristics);
+        mReadWriteLock.writeLock().unlock();
+    }
 
     private void clearUI(String address) {
-        //mReadWriteLock.readLock().lock();
-        //mDeviceGattServicesListView.get(address).setAdapter((SimpleExpandableListAdapter) null);
-        //mReadWriteLock.readLock().unlock();
-        //mReadWriteLock.writeLock().lock();
+        mReadWriteLock.readLock().lock();
+        mDeviceGattServicesListView.get(address).setAdapter((SimpleExpandableListAdapter) null);
+        mReadWriteLock.readLock().unlock();
+        mReadWriteLock.writeLock().lock();
         mDeviceDataValue.remove(address);
-        //mReadWriteLock.writeLock().lock();
+        mReadWriteLock.writeLock().lock();
     }
 
     @SuppressLint("ResourceType")
@@ -297,19 +294,6 @@ public class MultiDeviceControlActivity extends ListActivity {
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
 
-        //然后通过一个函数来申请
-            try {
-                //检测是否有写的权限
-                int permission = ActivityCompat.checkSelfPermission(this,
-                        "android.permission.WRITE_EXTERNAL_STORAGE");
-                if (permission != PackageManager.PERMISSION_GRANTED) {
-                    // 没有写的权限，去申请写的权限，会弹出对话框
-                    ActivityCompat.requestPermissions(this, PERMISSIONS_STORAGE,REQUEST_EXTERNAL_STORAGE);
-                }
-            } catch (Exception e) {
-                e.printStackTrace();
-            }
-
         getActionBar().setTitle(R.string.title_multi);
 
         final Intent intent = getIntent();
@@ -335,13 +319,14 @@ public class MultiDeviceControlActivity extends ListActivity {
         mMultiDeviceListAdapter = new MultiControlGattListAdapter();
         setListAdapter(mMultiDeviceListAdapter);
 
+
         registerReceiver(mGattUpdateReceiver, makeGattUpdateIntentFilter());
-//        if (mBluetoothLeService != null) {
-//            for (BluetoothLeData device : mDeviceList) {
-//                final boolean result = mBluetoothLeService.connect(device.getDeviceAddress());
-//                Log.d(TAG, "Connect" + device.getDataPiece() + "request result=" + result);
-//            }
-//        }
+        if (mBluetoothLeService != null) {
+            for (BluetoothLeData device : mDeviceList) {
+                final boolean result = mBluetoothLeService.connect(device.getDeviceAddress());
+                Log.d(TAG, "Connect" + device.getDataPiece() + "request result=" + result);
+            }
+        }
     }
 
     @Override
@@ -353,23 +338,19 @@ public class MultiDeviceControlActivity extends ListActivity {
     @Override
     protected void onDestroy() {
         super.onDestroy();
-
+        unbindService(mServiceConnection);
+        mBluetoothLeService = null;
         //TODO: ...
         for (BluetoothLeData device : mDeviceList) {
             closeOutputStream(device.getDeviceAddress());
-            mBluetoothLeService.disconnect(device.getDeviceAddress());
-            mDeviceConnectionState.put(device.getDeviceAddress(), false);
-            mDeviceDataValue.clear();
         }
-        unbindService(mServiceConnection);
-        mBluetoothLeService = null;
 
     }
 
     @Override
     public boolean onCreateOptionsMenu(Menu menu) {
         getMenuInflater().inflate(R.menu.gatt_services, menu);
-        //menu.findItem(R.id.menu_set_file).setVisible(true);
+        menu.findItem(R.id.menu_set_file).setVisible(true);
         //if (mConnected) {
         menu.findItem(R.id.menu_connect).setVisible(true);
         menu.findItem(R.id.menu_disconnect).setVisible(true);
@@ -380,58 +361,34 @@ public class MultiDeviceControlActivity extends ListActivity {
         return true;
     }
 
-    @RequiresApi(api = Build.VERSION_CODES.M)
-    @Override
-    protected void onListItemClick(ListView l, View v, int position, long id) {
-        final BluetoothLeData device = mMultiDeviceListAdapter.getDevice(position);
-        if (device == null) return;
-        if(mDeviceConnectionState.get(device.getDeviceAddress()) == null || !mDeviceConnectionState.get(device.getDeviceAddress())) {
-            boolean result = mBluetoothLeService.connect(device.getDeviceAddress());
-            mDeviceConnectionState.put(device.getDeviceAddress(), result);
-            Log.d(TAG, "Connect:" + device.getDataPiece() + "request result=" + result);
-        }
-        if(mDeviceConnectionState.get(device.getDeviceAddress())) {
-            openOutputStream(device.getDeviceAddress());
-        }
-        mMultiDeviceListAdapter.notifyDataSetChanged();
-    }
-
-
     @SuppressLint("NonConstantResourceId")
     @RequiresApi(api = Build.VERSION_CODES.M)
     @Override
     public boolean onOptionsItemSelected(MenuItem item) {
         switch (item.getItemId()) {
             case R.id.menu_connect:
-                boolean result;
                 for (BluetoothLeData device : mDeviceList) {
-                    result = mBluetoothLeService.connect(device.getDeviceAddress());
-                    mDeviceConnectionState.put(device.getDeviceAddress(), result);
-                    Log.d(TAG, "Connect:" + device.getDataPiece() + "request result=" + result);
+                    mBluetoothLeService.connect(device.getDeviceAddress());
                 }
                 return true;
             case R.id.menu_disconnect:
                 for (BluetoothLeData device : mDeviceList) {
                     mBluetoothLeService.disconnect(device.getDeviceAddress());
-                    mDeviceConnectionState.put(device.getDeviceAddress(), false);
-                    closeOutputStream(device.getDeviceAddress());
-                    Log.d(TAG, "Disconnect:" + device.getDataPiece());
                 }
                 return true;
-            //case R.id.menu_set_file:
-            //    initialUri();//设置保存文件目录205
-            //    return true;
+            case R.id.menu_set_file:
+                initialUri();//设置保存文件目录205
+                return true;
             case android.R.id.home:
                 onBackPressed();
                 return true;
         }
-        mMultiDeviceListAdapter.notifyDataSetChanged();
         return super.onOptionsItemSelected(item);
     }
 
     private class MultiControlGattListAdapter extends BaseAdapter {
-        private final ArrayList<BluetoothLeData> mLeDevices;
-        private final LayoutInflater mInflator;
+        private ArrayList<BluetoothLeData> mLeDevices;
+        private LayoutInflater mInflator;
 
         public MultiControlGattListAdapter() {
             super();
@@ -446,7 +403,9 @@ public class MultiDeviceControlActivity extends ListActivity {
         }
 
         public void removeDevice(BluetoothLeData device) {
-            mLeDevices.remove(device);
+            if (mLeDevices.contains(device)) {
+                mLeDevices.remove(device);
+            }
         }
 
         public BluetoothLeData getDevice(int position) {
@@ -472,14 +431,6 @@ public class MultiDeviceControlActivity extends ListActivity {
             return i;
         }
 
-        public int getItemId(String address) {
-            for (int i = 0; i < mLeDevices.size(); i++) {
-                if (mLeDevices.get(i).getDeviceAddress().equalsIgnoreCase(address))
-                    return i;
-            }
-            return -1;
-        }
-
         @Override
         public View getView(int i, View view, ViewGroup viewGroup) {
             MultiDeviceControlActivity.ViewHolder viewHolder;
@@ -490,7 +441,7 @@ public class MultiDeviceControlActivity extends ListActivity {
                 viewHolder.deviceAddress = (TextView) view.findViewById(R.id.device_address);
                 viewHolder.connectionState = (TextView) view.findViewById(R.id.connection_state);
                 viewHolder.dataValue = (TextView) view.findViewById(R.id.data_value);
-                //viewHolder.gattServicesList = (ExpandableListView) view.findViewById(R.id.gatt_services_list);
+                viewHolder.gattServicesList = (ExpandableListView) view.findViewById(R.id.gatt_services_list);
                 view.setTag(viewHolder);
             } else {
                 viewHolder = (MultiDeviceControlActivity.ViewHolder) view.getTag();
@@ -501,39 +452,75 @@ public class MultiDeviceControlActivity extends ListActivity {
 
             viewHolder.deviceAddress.setText(device.getDataPiece() + deviceAddress);
 
-            viewHolder.connectionState.setText(mDeviceConnectionState.containsKey(deviceAddress) ?
-                    (mDeviceConnectionState.get(deviceAddress).booleanValue() ?
-                            R.string.connected : R.string.disconnected) : R.string.disconnected);
-            if (mDeviceDataValue.containsKey(deviceAddress) && mDeviceDataValue.get(deviceAddress) != null) {
-                viewHolder.dataValue.setText(mDeviceDataValue.get(deviceAddress));
-            } else {
-                viewHolder.dataValue.setText(R.string.no_data);
-            }
-                //mReadWriteLock.readLock().unlock();
+            runOnUiThread(() -> {
+                    ArrayList<ArrayList<BluetoothGattCharacteristic>> gattCharacteristics = mDeviceGattCharacteristics.get(deviceAddress);
+                    viewHolder.gattServicesList.setOnChildClickListener(
+                            (parent, v, groupPosition, childPosition, id) -> {
+                                if (gattCharacteristics != null) {
+                                    final BluetoothGattCharacteristic characteristic =
+                                            gattCharacteristics.get(groupPosition).get(childPosition);
+                                    final int charaProp = characteristic.getProperties();
+                                    if ((charaProp & BluetoothGattCharacteristic.PROPERTY_READ) > 0) {
+                                        // If there is an active notification on a characteristic, clear
+                                        // it first so it doesn't update the data field on the user interface.
+                                        if (mDeviceNotifyCharacteristic.get(deviceAddress) != null) {
+                                            mBluetoothLeService.setCharacteristicNotification(
+                                                    deviceAddress,
+                                                    mDeviceNotifyCharacteristic.get(deviceAddress), false);
+                                            mDeviceNotifyCharacteristic.remove(deviceAddress);
+                                        }
+                                        mBluetoothLeService.readCharacteristic(characteristic);
+                                        Log.d(TAG, "GATT PROPERTY_READ: " + charaProp);
+                                    }
+                                    if ((charaProp & BluetoothGattCharacteristic.PROPERTY_NOTIFY) > 0) {
+                                        mDeviceNotifyCharacteristic.put(deviceAddress, characteristic);
+                                        mBluetoothLeService.setCharacteristicNotification(
+                                                characteristic, true);
+                                        Log.d(TAG, "GATT PROPERTY_NOTIFY: " + charaProp);
+
+                                    }
+                                    return true;
+                                }
+                                return false;
+                            });
+                mReadWriteLock.writeLock().lock();
+                mDeviceGattServicesListView.put(deviceAddress, viewHolder.gattServicesList);
+                mReadWriteLock.writeLock().unlock();
+                mReadWriteLock.readLock().lock();
+                viewHolder.connectionState.setText(mDeviceConnectionState.containsKey(deviceAddress) ?
+                        (mDeviceConnectionState.get(deviceAddress).booleanValue() ?
+                                R.string.connected : R.string.disconnected) : R.string.disconnected);
+                if (mDeviceDataValue.containsKey(deviceAddress)) {
+                    viewHolder.dataValue.setText(mDeviceDataValue.get(deviceAddress));
+                } else {
+                    viewHolder.dataValue.setText(R.string.no_data);
+                }
+                mReadWriteLock.readLock().unlock();
+            });
 
             return view;
         }
     }
 
-//    private void displayData(String address, String data) {
-//        if (data != null) {
-//            //mReadWriteLock.writeLock().lock();
-//            mDeviceDataValue.put(address, data);
-//            //mReadWriteLock.writeLock().lock();
-//        }
-//    }
+    private void displayData(String address, String data) {
+        if (data != null) {
+            mReadWriteLock.writeLock().lock();
+            mDeviceDataValue.put(address, data);
+            mReadWriteLock.writeLock().lock();
+        }
+    }
 
-//    private void updateConnectionState(String address, boolean connected) {
-//        //mReadWriteLock.writeLock().lock();
-//        mDeviceConnectionState.put(address, connected);
-//        //mReadWrite77.writeLock().unlock();
-//    }
+    private void updateConnectionState(String address, boolean connected) {
+        mReadWriteLock.writeLock().lock();
+        mDeviceConnectionState.put(address, connected);
+        mReadWriteLock.writeLock().unlock();
+    }
 
     static class ViewHolder {
         TextView deviceAddress;
         TextView connectionState;
         TextView dataValue;
-        //ExpandableListView gattServicesList;
+        ExpandableListView gattServicesList;
     }
 
     private static IntentFilter makeGattUpdateIntentFilter() {
@@ -545,4 +532,130 @@ public class MultiDeviceControlActivity extends ListActivity {
         intentFilter.addAction(BluetoothLeService.ACTION_DATA_WRITABLE);
         return intentFilter;
     }
+
+
+    public void setListViewHeightBasedOnChildren(ListView listView) {
+        ListAdapter listAdapter = listView.getAdapter();
+        ViewGroup.LayoutParams params = listView.getLayoutParams();
+        if (listAdapter == null) {
+            // pre-condition
+            return;
+        }
+        int totalHeight = 0;
+        View view;
+        for (int i = 0; i < listAdapter.getCount(); i++) {
+            view = listAdapter.getView(i, null, listView);
+            //宽度为屏幕宽度
+            int i1 = View.MeasureSpec.makeMeasureSpec(ScreenUtils.getScreenWidth(this), View.MeasureSpec.EXACTLY);
+            //根据屏幕宽度计算高度
+            int i2 = View.MeasureSpec.makeMeasureSpec(i1, View.MeasureSpec.UNSPECIFIED);
+            view.measure(i1, i2);
+            totalHeight += view.getMeasuredHeight();
+        }
+        params.height = totalHeight + (listView.getDividerHeight() * (listAdapter.getCount() - 1));
+        listView.setLayoutParams(params);
+    }
+
+    //获得屏幕相关的辅助类
+    public static class ScreenUtils {
+        private ScreenUtils() {
+            /* cannot be instantiated */
+            throw new UnsupportedOperationException("cannot be instantiated");
+        }
+
+        /**
+         * 获得屏幕高度
+         *
+         * @param context
+         * @return
+         */
+        public static int getScreenWidth(Context context) {
+            WindowManager wm = (WindowManager) context
+                    .getSystemService(Context.WINDOW_SERVICE);
+            DisplayMetrics outMetrics = new DisplayMetrics();
+            wm.getDefaultDisplay().getMetrics(outMetrics);
+            return outMetrics.widthPixels;
+        }
+
+        /**
+         * 获得屏幕宽度
+         *
+         * @param context
+         * @return
+         */
+        public static int getScreenHeight(Context context) {
+            WindowManager wm = (WindowManager) context
+                    .getSystemService(Context.WINDOW_SERVICE);
+            DisplayMetrics outMetrics = new DisplayMetrics();
+            wm.getDefaultDisplay().getMetrics(outMetrics);
+            return outMetrics.heightPixels;
+        }
+
+        /**
+         * 获得状态栏的高度
+         *
+         * @param context
+         * @return
+         */
+        public static int getStatusHeight(Context context) {
+
+            int statusHeight = -1;
+            try {
+                Class<?> clazz = Class.forName("com.android.internal.R$dimen");
+                Object object = clazz.newInstance();
+                int height = Integer.parseInt(clazz.getField("status_bar_height")
+                        .get(object).toString());
+                statusHeight = context.getResources().getDimensionPixelSize(height);
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+            return statusHeight;
+        }
+
+        /**
+         * 获取当前屏幕截图，包含状态栏
+         *
+         * @param activity
+         * @return
+         */
+        public static Bitmap snapShotWithStatusBar(Activity activity) {
+            View view = activity.getWindow().getDecorView();
+            view.setDrawingCacheEnabled(true);
+            view.buildDrawingCache();
+            Bitmap bmp = view.getDrawingCache();
+            int width = getScreenWidth(activity);
+            int height = getScreenHeight(activity);
+            Bitmap bp = null;
+            bp = Bitmap.createBitmap(bmp, 0, 0, width, height);
+            view.destroyDrawingCache();
+            return bp;
+
+        }
+
+        /**
+         * 获取当前屏幕截图，不包含状态栏
+         *
+         * @param activity
+         * @return
+         */
+        public static Bitmap snapShotWithoutStatusBar(Activity activity) {
+            View view = activity.getWindow().getDecorView();
+            view.setDrawingCacheEnabled(true);
+            view.buildDrawingCache();
+            Bitmap bmp = view.getDrawingCache();
+            Rect frame = new Rect();
+            activity.getWindow().getDecorView().getWindowVisibleDisplayFrame(frame);
+            int statusBarHeight = frame.top;
+
+            int width = getScreenWidth(activity);
+            int height = getScreenHeight(activity);
+            Bitmap bp = null;
+            bp = Bitmap.createBitmap(bmp, 0, statusBarHeight, width, height
+                    - statusBarHeight);
+            view.destroyDrawingCache();
+            return bp;
+
+        }
+
+    }
 }
\ No newline at end of file
diff --git a/Application/src/main/res/values/strings.xml b/Application/src/main/res/values/strings.xml
index a3a33b0..da208ee 100644
--- a/Application/src/main/res/values/strings.xml
+++ b/Application/src/main/res/values/strings.xml
@@ -49,7 +49,5 @@
     <string name="uri_initial"> .URI_INITIAL</string>
     <string name="uri_initialized"> Uri for saving is initialized</string>
     <string name="title_multi"> Multi Device Connection</string>
-    <string name="file_created">output file has been created.</string>
-    <string name="file_existed">output file has already existed.</string>
 
 </resources>
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index a0f7639..1f3fdbc 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,5 +1,5 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-7.2-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-6.7.1-all.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
